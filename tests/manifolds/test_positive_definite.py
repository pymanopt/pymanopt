import pytest
from numpy import complex128, float64

from pymanopt.manifolds import (
    HermitianPositiveDefinite,
    SpecialHermitianPositiveDefinite,
    SymmetricPositiveDefinite,
)
from pymanopt.numerics import NumpyNumericsBackend


def geodesic(point_a, point_b, alpha, backend):
    if alpha < 0 or 1 < alpha:
        raise ValueError("Exponent must be in [0,1]")
    c = backend.linalg_cholesky(point_a)
    c_inv = backend.linalg_inv(c)
    log_cbc = backend.linalg_logm(
        c_inv @ point_b @ backend.conjugate_transpose(c_inv),
        positive_definite=True,
    )
    powm = backend.linalg_expm(alpha * log_cbc, symmetric=False)
    return c @ powm @ backend.conjugate_transpose(c)


class TestSingleSymmetricPositiveDefiniteManifold:
    @pytest.fixture(autouse=True)
    def setup(self):
        self.n = n = 15
        self.backend = NumpyNumericsBackend()
        self.manifold = SymmetricPositiveDefinite(n, backend=self.backend)

    def test_random_point(self):
        # Just test that rand returns a point on the manifold and two
        # different matrices generated by rand aren't too close together
        n = self.n
        manifold = self.manifold
        x = manifold.random_point()

        assert x.shape == (n, n)

        # Check symmetry
        self.backend.assert_allclose(x, self.backend.sym(x))

        # Check positivity of eigenvalues
        w = self.backend.linalg_eigvalsh(x)
        assert (w > [0]).all()

    def test_dist(self):
        manifold = self.manifold
        x = manifold.random_point()
        y = manifold.random_point()
        z = manifold.random_point()

        # Test separability
        self.backend.assert_almost_equal(manifold.dist(x, x), 0.0)

        # Test symmetry
        self.backend.assert_almost_equal(
            manifold.dist(x, y), manifold.dist(y, x)
        )

        # Test triangle inequality
        assert manifold.dist(x, y) <= manifold.dist(x, z) + manifold.dist(z, y)

        # Test alternative implementation (see equation (6.14) in [Bha2007]).
        d = self.backend.sqrt(
            (self.backend.log(self.backend.linalg_eigvalsh(x, y)) ** 2).sum()
        )
        self.backend.assert_almost_equal(manifold.dist(x, y), d)

        # Test exponential metric increasing property
        # (see equation (6.8) in [Bha2007]).
        assert manifold.dist(x, y) >= self.backend.linalg_norm(
            self.backend.linalg_logm(x) - self.backend.linalg_logm(y)
        )

        # check that dist is consistent with log
        self.backend.assert_almost_equal(
            manifold.dist(x, y), manifold.norm(x, manifold.log(x, y))
        )

        # Test invariance under inversion
        self.backend.assert_almost_equal(
            manifold.dist(x, y),
            manifold.dist(
                self.backend.linalg_inv(y), self.backend.linalg_inv(x)
            ),
        )

        # Test congruence-invariance
        a = self.backend.random_normal(
            size=(self.n, self.n)
        )  # must be invertible
        axa = a @ x @ self.backend.transpose(a)
        aya = a @ y @ self.backend.transpose(a)
        self.backend.assert_almost_equal(
            manifold.dist(x, y), manifold.dist(axa, aya)
        )

        # Test proportionality (see equation (6.12) in [Bha2007]).
        alpha = self.backend.random_uniform()
        self.backend.assert_almost_equal(
            manifold.dist(x, geodesic(x, y, alpha, self.backend)),
            alpha * manifold.dist(x, y),
        )

    def test_exp(self):
        manifold = self.manifold
        x = manifold.random_point()
        u = manifold.random_tangent_vector(x)
        e = self.backend.linalg_expm(self.backend.linalg_solve(x, u))

        self.backend.assert_allclose(x @ e, manifold.exp(x, u))
        u = u * 1e-6
        self.backend.assert_allclose(manifold.exp(x, u), x + u)

    def test_random_tangent_vector(self):
        # Just test that random_tangent_vector returns an element of the tangent space
        # with norm 1 and that two random_tangent_vectors are different.
        manifold = self.manifold
        x = manifold.random_point()
        u = manifold.random_tangent_vector(x)
        v = manifold.random_tangent_vector(x)
        self.backend.assert_allclose(self.backend.herm(u), u)
        self.backend.assert_almost_equal(1, manifold.norm(x, u))
        assert self.backend.linalg_norm(u - v) > 1e-3

    def test_norm(self):
        manifold = self.manifold
        x = manifold.random_point()
        self.backend.assert_almost_equal(
            manifold.norm(self.backend.eye(self.n), x),
            self.backend.linalg_norm(x),
        )

    def test_exp_log_inverse(self):
        manifold = self.manifold
        x = manifold.random_point()
        y = manifold.random_point()
        u = manifold.log(x, y)
        self.backend.assert_allclose(manifold.exp(x, u), y)

    def test_log_exp_inverse(self):
        manifold = self.manifold
        x = manifold.random_point()
        u = manifold.random_tangent_vector(x)
        y = manifold.exp(x, u)
        self.backend.assert_allclose(manifold.log(x, y), u)


class TestSingleHermitianPositiveDefiniteManifold(
    TestSingleSymmetricPositiveDefiniteManifold
):
    @pytest.fixture(autouse=True)
    def setup(self):
        self.n = n = 15
        self.backend = NumpyNumericsBackend(dtype=complex128)
        self.manifold = HermitianPositiveDefinite(n, backend=self.backend)

    def test_dim(self):
        manifold = self.manifold
        n = self.n
        self.backend.assert_equal(manifold.dim, n * (n + 1))

    def test_random_point(self):
        # Just test that random_point returns a point on the manifold and two
        # different matrices generated by random_point aren't too close together
        n = self.n
        manifold = self.manifold
        x = manifold.random_point()

        assert x.shape == (n, n)
        assert x.dtype == self.backend.dtype

        # Check symmetry
        self.backend.assert_allclose(x, self.backend.herm(x))

        # Check positivity of eigenvalues
        w = self.backend.linalg_eigvalsh(x)
        assert (w > [0]).all()

    def test_random_tangent_vector(self):
        # Just test that randvec returns an element of the tangent space
        # with norm 1 and that two randvecs are different.
        manifold = self.manifold
        x = manifold.random_point()
        u = manifold.random_tangent_vector(x)
        v = manifold.random_tangent_vector(x)
        self.backend.assert_allclose(self.backend.herm(u), u)
        self.backend.assert_almost_equal(1, manifold.norm(x, u))
        assert u.shape == (self.n, self.n)
        assert u.dtype == self.backend.dtype
        assert self.backend.linalg_norm(u - v) > 1e-3


class TestMultiSymmetricPositiveDefiniteManifold:
    @pytest.fixture(autouse=True)
    def setup(self):
        self.n = n = 10
        self.k = k = 3
        self.backend = NumpyNumericsBackend(dtype=float64)
        self.manifold = SymmetricPositiveDefinite(n, k=k, backend=self.backend)

    def test_dim(self):
        manifold = self.manifold
        n = self.n
        k = self.k
        self.backend.assert_equal(manifold.dim, 0.5 * k * n * (n + 1))

    def test_typical_dist(self):
        manifold = self.manifold
        self.backend.assert_equal(
            manifold.typical_dist, self.backend.sqrt(manifold.dim)
        )

    def test_dist(self):
        # n = self.n
        manifold = self.manifold
        x = manifold.random_point()
        y = manifold.random_point()
        z = manifold.random_point()

        # Test separability
        self.backend.assert_almost_equal(manifold.dist(x, x), 0.0)

        # Test symmetry
        self.backend.assert_almost_equal(
            manifold.dist(x, y), manifold.dist(y, x)
        )

        # Test triangle inequality
        assert manifold.dist(x, y) <= manifold.dist(x, z) + manifold.dist(z, y)

        # Test exponential metric increasing property
        # (see equation (6.8) in [Bha2007]).
        logx, logy = self.backend.linalg_logm(x), self.backend.linalg_logm(y)
        assert manifold.dist(x, y) >= self.backend.linalg_norm(logx - logy)

        # check that dist is consistent with log
        self.backend.assert_almost_equal(
            manifold.dist(x, y), manifold.norm(x, manifold.log(x, y))
        )

        # Test invariance under inversion
        self.backend.assert_almost_equal(
            manifold.dist(x, y),
            manifold.dist(
                self.backend.linalg_inv(y), self.backend.linalg_inv(x)
            ),
        )

        # Test congruence-invariance
        a = self.backend.random_normal(
            size=(self.n, self.n)
        )  # must be invertible
        axa = a @ x @ self.backend.transpose(a)
        aya = a @ y @ self.backend.transpose(a)
        self.backend.assert_almost_equal(
            manifold.dist(x, y), manifold.dist(axa, aya)
        )

        # Test proportionality (see equation (6.12) in [Bha2007]).
        alpha = self.backend.random_uniform()
        self.backend.assert_almost_equal(
            manifold.dist(x, geodesic(x, y, alpha, self.backend)),
            alpha * manifold.dist(x, y),
        )

    def test_inner_product(self):
        manifold = self.manifold
        k = self.k
        n = self.n
        x = manifold.random_point()
        a, b = self.backend.random_normal(size=(2, k, n, n))
        self.backend.assert_almost_equal(
            self.backend.tensordot(a, b.transpose((0, 2, 1)), axes=a.ndim),
            manifold.inner_product(x, x @ a, x @ b),
        )

    def test_projection(self):
        manifold = self.manifold
        x = manifold.random_point()
        a = self.backend.random_normal(size=(self.k, self.n, self.n))
        self.backend.assert_allclose(
            manifold.projection(x, a), self.backend.herm(a)
        )

    def test_euclidean_to_riemannian_gradient(self):
        manifold = self.manifold
        x = manifold.random_point()
        u = self.backend.random_normal(size=(self.k, self.n, self.n))
        self.backend.assert_allclose(
            manifold.euclidean_to_riemannian_gradient(x, u),
            x @ self.backend.herm(u) @ x,
        )

    def test_euclidean_to_riemannian_hessian(self):
        # Use manopt's slow method
        manifold = self.manifold
        n = self.n
        k = self.k
        x = manifold.random_point()
        egrad, ehess = self.backend.random_normal(size=(2, k, n, n))
        u = manifold.random_tangent_vector(x)

        Hess = x @ self.backend.herm(ehess) @ x + 2 * self.backend.herm(
            u @ self.backend.herm(egrad) @ x
        )

        # Correction factor for the non-constant metric
        Hess = Hess - self.backend.herm(u @ self.backend.herm(egrad) @ x)
        self.backend.assert_almost_equal(
            Hess, manifold.euclidean_to_riemannian_hessian(x, egrad, ehess, u)
        )

    def test_norm(self):
        manifold = self.manifold
        x = manifold.random_point()
        Id = self.backend.array(self.k * [self.backend.eye(self.n)])
        self.backend.assert_almost_equal(
            manifold.norm(Id, x), self.backend.linalg_norm(x)
        )

    def test_random_point(self):
        # Just test that rand returns a point on the manifold and two
        # different matrices generated by rand aren't too close together
        k = self.k
        n = self.n
        manifold = self.manifold
        x = manifold.random_point()

        assert x.shape == (k, n, n)

        # Check symmetry
        self.backend.assert_allclose(x, self.backend.sym(x))

        # Check positivity of eigenvalues
        # breakpoint()
        w = self.backend.linalg_eigvalsh(x)
        assert (w > [[0]]).all()

    def test_random_tangent_vector(self):
        # Just test that random_tangent_vector returns an element of the tangent space
        # with norm 1 and that two random_tangent_vectors are different.
        manifold = self.manifold
        x = manifold.random_point()
        u = manifold.random_tangent_vector(x)
        v = manifold.random_tangent_vector(x)
        self.backend.assert_allclose(self.backend.sym(u), u)
        self.backend.assert_almost_equal(1, manifold.norm(x, u))
        assert self.backend.linalg_norm(u - v) > 1e-3

    def test_transport(self):
        manifold = self.manifold
        x = manifold.random_point()
        y = manifold.random_point()
        u = manifold.random_tangent_vector(x)
        u_transp = manifold.transport(x, y, u)
        u_transp_proj = manifold.projection(y, u_transp)
        self.backend.assert_allclose(u_transp, u_transp_proj)

    def test_exp(self):
        # Test against manopt implementation, test that for small vectors
        # exp(x, u) = x + u.
        manifold = self.manifold
        x = manifold.random_point()
        u = manifold.random_tangent_vector(x)
        e = self.backend.zeros_like(x)
        for i in range(self.k):
            e[i] = self.backend.linalg_expm(
                self.backend.linalg_solve(x[i], u[i])
            )
        self.backend.assert_allclose(x @ e, manifold.exp(x, u))
        u = u * 1e-6
        self.backend.assert_allclose(manifold.exp(x, u), x + u)

    def test_retraction(self):
        # Check that result is on manifold and for small vectors
        # retr(x, u) = x + u.
        manifold = self.manifold
        x = manifold.random_point()
        u = manifold.random_tangent_vector(x)
        y = manifold.retraction(x, u)

        assert y.shape == (self.k, self.n, self.n)
        # Check symmetry
        self.backend.assert_allclose(y, self.backend.herm(y))

        # Check positivity of eigenvalues
        w = self.backend.linalg_eigvalsh(y)
        assert (w > [[0]]).all()

        u = u * 1e-6
        self.backend.assert_allclose(manifold.retraction(x, u), x + u)

    def test_exp_log_inverse(self):
        manifold = self.manifold
        x = manifold.random_point()
        y = manifold.random_point()
        u = manifold.log(x, y)
        self.backend.assert_allclose(manifold.exp(x, u), y)

    def test_log_exp_inverse(self):
        manifold = self.manifold
        x = manifold.random_point()
        u = manifold.random_tangent_vector(x)
        y = manifold.exp(x, u)
        self.backend.assert_allclose(manifold.log(x, y), u)


class TestMultiHermitianPositiveDefiniteManifold(
    TestMultiSymmetricPositiveDefiniteManifold
):
    @pytest.fixture(autouse=True)
    def setup(self):
        self.n = n = 10
        self.k = k = 3
        self.backend = NumpyNumericsBackend(dtype=complex128)
        self.manifold = HermitianPositiveDefinite(n, k=k, backend=self.backend)

    def test_dim(self):
        manifold = self.manifold
        n = self.n
        k = self.k
        self.backend.assert_equal(manifold.dim, k * n * (n + 1))

    def test_random_point(self):
        # Just test that rand returns a point on the manifold and two
        # different matrices generated by rand aren't too close together
        k = self.k
        n = self.n
        manifold = self.manifold
        x = manifold.random_point()

        assert x.shape == (k, n, n)
        assert x.dtype == self.backend.dtype

        # Check symmetry
        self.backend.assert_allclose(x, self.backend.herm(x))

        # Check positivity of eigenvalues
        w = self.backend.linalg_eigvalsh(x)
        assert (w > [[0]]).all()

    def test_random_tangent_vector(self):
        # Just test that randvec returns an element of the tangent space
        # with norm 1 and that two randvecs are different.
        k = self.k
        n = self.n
        manifold = self.manifold
        x = manifold.random_point()
        u = manifold.random_tangent_vector(x)
        v = manifold.random_tangent_vector(x)
        self.backend.assert_allclose(self.backend.herm(u), u)
        self.backend.assert_almost_equal(1, manifold.norm(x, u))
        assert u.shape == (k, n, n)
        assert self.backend.linalg_norm(u - v) > 1e-3


class TestSingleSpecialHermitianPositiveDefiniteManifold(
    TestSingleHermitianPositiveDefiniteManifold
):
    @pytest.fixture(autouse=True)
    def setup(self):
        self.n = n = 10
        self.k = k = 1
        self.backend = NumpyNumericsBackend(dtype=complex128)
        self.manifold = SpecialHermitianPositiveDefinite(
            n, k=k, backend=self.backend
        )

    def test_dim(self):
        manifold = self.manifold
        n = self.n
        self.backend.assert_equal(manifold.dim, n * (n + 1) - 1)

    def test_random_point(self):
        # Just test that rand returns a point on the manifold and two
        # different matrices generated by rand aren't too close together
        n = self.n
        manifold = self.manifold
        x = manifold.random_point()
        y = manifold.random_point()

        assert x.shape == (n, n)
        assert x.dtype == self.backend.dtype

        # Check symmetry
        self.backend.assert_allclose(x, self.backend.herm(x))

        # Check positivity of eigenvalues
        w = self.backend.linalg_eigvalsh(x)
        assert (w > [[0]]).all()

        # Check unit determinant
        d = self.backend.real(self.backend.linalg_det(x))
        self.backend.assert_allclose(d, 1)

        # Check randomness
        assert self.backend.linalg_norm(x - y) > 1e-3

    def test_random_tangent_vector(self):
        # Just test that randvec returns an element of the tangent space
        # with norm 1 and that two randvecs are different.
        manifold = self.manifold
        n = self.n
        x = manifold.random_point()
        u = manifold.random_tangent_vector(x)
        v = manifold.random_tangent_vector(x)

        assert x.shape == (n, n)
        assert x.dtype == self.backend.dtype

        self.backend.assert_allclose(self.backend.herm(u), u)

        t = self.backend.real(
            self.backend.trace(self.backend.linalg_solve(x, u))
        )
        self.backend.assert_almost_equal(t, 0)

        self.backend.assert_almost_equal(1, manifold.norm(x, u))

        assert self.backend.linalg_norm(u - v) > 1e-3

    def test_projection(self):
        manifold = self.manifold
        x = manifold.random_point()
        a = self.backend.random_randn(
            self.n, self.n
        ) + 1j * self.backend.random_randn(self.n, self.n)
        p = manifold.projection(x, a)

        assert p.shape == (self.n, self.n)

        self.backend.assert_allclose(p, self.backend.herm(p))

        t = self.backend.real(
            self.backend.trace(self.backend.linalg_solve(x, p))
        )
        self.backend.assert_almost_equal(t, 0)

        self.backend.assert_allclose(p, manifold.projection(x, p))

    def test_euclidean_to_riemannian_gradient(self):
        manifold = self.manifold
        x = manifold.random_point()
        u = self.backend.random_normal(size=(self.k, self.n, self.n))
        self.backend.assert_allclose(
            manifold.euclidean_to_riemannian_gradient(x, u),
            manifold.projection(x, x @ u @ x),
        )

    def test_exp(self):
        # Test against manopt implementation, test that for small vectors
        # exp(x, u) = x + u.
        manifold = self.manifold
        x = manifold.random_point()
        u = manifold.random_tangent_vector(x)
        e = manifold.exp(x, u)
        assert e.shape == (self.n, self.n)

        # Check symmetry
        self.backend.assert_allclose(e, self.backend.herm(e))

        # Check positivity of eigenvalues
        w = self.backend.linalg_eigvalsh(e)
        assert (w > [[0]]).all()

        # Check unit determinant
        d = self.backend.linalg_det(e)
        self.backend.assert_allclose(d, 1)

        u = u * 1e-6
        self.backend.assert_allclose(manifold.exp(x, u), x + u)

    def test_retraction(self):
        # Check that result is on manifold and for small vectors
        # retraction(x, u) = x + u.
        manifold = self.manifold
        x = manifold.random_point()
        u = manifold.random_tangent_vector(x)
        y = manifold.retraction(x, u)

        assert y.shape == (self.n, self.n)
        # Check symmetry
        self.backend.assert_allclose(y, self.backend.herm(y))

        # Check positivity of eigenvalues
        w = self.backend.linalg_eigvalsh(y)
        assert (w > [[0]]).all()

        # Check unit determinant
        d = self.backend.linalg_det(y)
        self.backend.assert_allclose(d, 1)

        u = u * 1e-6
        self.backend.assert_allclose(manifold.retraction(x, u), x + u)


class TestMultiSpecialHermitianPositiveDefiniteManifold(
    TestMultiHermitianPositiveDefiniteManifold
):
    @pytest.fixture(autouse=True)
    def setup(self):
        self.n = n = 10
        self.k = k = 3
        self.backend = NumpyNumericsBackend(dtype=complex128)
        self.manifold = SpecialHermitianPositiveDefinite(
            n, k=k, backend=self.backend
        )

    def test_dim(self):
        manifold = self.manifold
        n = self.n
        k = self.k
        self.backend.assert_equal(manifold.dim, k * (n * (n + 1) - 1))

    def test_random_point(self):
        # Just test that rand returns a point on the manifold and two
        # different matrices generated by rand aren't too close together
        k = self.k
        n = self.n
        manifold = self.manifold
        x = manifold.random_point()
        y = manifold.random_point()

        assert x.shape == (k, n, n)
        assert x.dtype == self.backend.dtype

        # Check symmetry
        self.backend.assert_allclose(x, self.backend.herm(x))

        # Check positivity of eigenvalues
        w = self.backend.linalg_eigvalsh(x)
        assert (w > [[0]]).all()

        # Check unit determinant
        d = self.backend.real(self.backend.linalg_det(x))
        self.backend.assert_allclose(d, 1)

        # Check randomness
        assert self.backend.linalg_norm(x - y) > 1e-3

    def test_random_tangent_vector(self):
        # Just test that randvec returns an element of the tangent space
        # with norm 1 and that two randvecs are different.
        manifold = self.manifold
        x = manifold.random_point()
        u = manifold.random_tangent_vector(x)
        v = manifold.random_tangent_vector(x)

        self.backend.assert_allclose(self.backend.herm(u), u)

        t = self.backend.zeros(manifold._k)
        temp = self.backend.linalg_solve(x, u)
        for i in range(manifold._k):
            t[i] = self.backend.real(self.backend.trace(temp[i, :, :]))
        self.backend.assert_allclose(t, 0, atol=1e-7)

        self.backend.assert_almost_equal(1, manifold.norm(x, u))

        assert self.backend.linalg_norm(u - v) > 1e-3

    def test_projection(self):
        manifold = self.manifold
        x = manifold.random_point()
        a = self.backend.random_randn(
            self.k, self.n, self.n
        ) + 1j * self.backend.random_randn(self.k, self.n, self.n)
        p = manifold.projection(x, a)

        self.backend.assert_allclose(p, self.backend.herm(p))

        t = self.backend.ones(manifold._k)
        temp = self.backend.linalg_solve(x, p)
        for i in range(manifold._k):
            t[i] = self.backend.real(self.backend.trace(temp[i, :, :]))
        self.backend.assert_allclose(t, 0, atol=1e-7)

        self.backend.assert_allclose(p, manifold.projection(x, p))

    def test_euclidean_to_riemannian_gradient(self):
        manifold = self.manifold
        x = manifold.random_point()
        u = self.backend.random_normal(size=(self.k, self.n, self.n))
        self.backend.assert_allclose(
            manifold.euclidean_to_riemannian_gradient(x, u),
            manifold.projection(x, x @ u @ x),
        )

    def test_euclidean_to_riemannian_hessian(self):
        pass

    def test_exp(self):
        # Test against manopt implementation, test that for small vectors
        # exp(x, u) = x + u.
        manifold = self.manifold
        x = manifold.random_point()
        u = manifold.random_tangent_vector(x)
        e = manifold.exp(x, u)

        # Check symmetry
        self.backend.assert_allclose(e, self.backend.herm(e))

        # Check positivity of eigenvalues
        w = self.backend.linalg_eigvalsh(e)
        assert (w > [[0]]).all()

        # Check unit determinant
        d = self.backend.linalg_det(e)
        self.backend.assert_allclose(d, 1)

        u = u * 1e-6
        self.backend.assert_allclose(manifold.exp(x, u), x + u)

    def test_retraction(self):
        # Check that result is on manifoldifold and for small vectors
        # retraction(x, u) = x + u.
        manifold = self.manifold
        x = manifold.random_point()
        u = manifold.random_tangent_vector(x)
        y = manifold.retraction(x, u)

        assert y.shape == (self.k, self.n, self.n)
        # Check symmetry
        self.backend.assert_allclose(y, self.backend.herm(y))

        # Check positivity of eigenvalues
        w = self.backend.linalg_eigvalsh(y)
        assert (w > [[0]]).all()

        # Check unit determinant
        d = self.backend.linalg_det(y)
        self.backend.assert_allclose(d, 1)

        u = u * 1e-6
        self.backend.assert_allclose(manifold.retraction(x, u), x + u)
